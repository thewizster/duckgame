<!DOCTYPE html>
<html>
<head>
    <title>8-Bit Duck Survival</title>
    <style>
        body {
            margin: 0;
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
            border: 4px solid #fff;
        }
        canvas {
            background-color: #5c94fc;
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        .controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            opacity: 0.8;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <div id="ui">
            LEVEL: <span id="levelDisplay">1</span><br>
            BURSTS: <span id="burstDisplay">1</span> âš¡
        </div>
        <canvas id="gameCanvas" width="800" height="450"></canvas>
        <div class="controls">SPACE: Swim/Hop | SHIFT: Super Burst Flight</div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const levelDisplay = document.getElementById('levelDisplay');
    const burstDisplay = document.getElementById('burstDisplay');

    // --- AUDIO ENGINE (Retro Synths) ---
    let audioCtx = null;
    let musicInterval = null;
    let isMusicPlaying = false;

    // FIXED: Added missing high notes (D5, etc) to prevent crashes
    const noteFreqs = {
        C3: 130.81, D3: 146.83, E3: 164.81, F3: 174.61, G3: 196.00, A3: 220.00, B3: 246.94,
        C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.00, A4: 440.00, B4: 493.88,
        C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99
    };

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        if (!isMusicPlaying) {
            startBackgroundMusic();
        }
    }

    function playTone(freq, type, duration, volume = 0.1) {
        if (!audioCtx) return;
        if (!freq) return; // Safety check: don't crash if note is missing

        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        osc.type = type; 
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        // Smooth envelope to avoid clicking sounds
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function sfxJump() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(300, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    function sfxBurst() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    }

    function sfxDie() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
        stopMusic();
    }

    function sfxWin() {
        if (!audioCtx) return;
        let now = audioCtx.currentTime;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, now + i*0.1);
            gain.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now + i*0.1);
            osc.stop(now + i*0.1 + 0.1);
        });
    }

    function startBackgroundMusic() {
        if (isMusicPlaying) return;
        isMusicPlaying = true;
        
        let noteIndex = 0;
        const melody = [
            'C4', 'E4', 'G4', 'C5', 'G4', 'E4', 'C4', 'P',
            'D4', 'F4', 'A4', 'D5', 'A4', 'F4', 'D4', 'P',
            'E4', 'G4', 'B4', 'E5', 'B4', 'G4', 'E4', 'P',
            'G3', 'B3', 'D4', 'G4', 'D4', 'B3', 'G3', 'P' 
        ];

        musicInterval = setInterval(() => {
            // Only play music if game is actually in PLAYING state
            if (gameState !== "PLAYING") return;
            
            let note = melody[noteIndex];
            if (note !== 'P') { 
                // Main Melody
                playTone(noteFreqs[note], 'square', 0.1, 0.03); 
                
                // Bassline (Simple 1-5 pattern)
                if (noteIndex % 4 === 0) {
                    // If freq exists, play bass an octave lower
                    if (noteFreqs[note]) {
                        playTone(noteFreqs[note] / 2, 'triangle', 0.2, 0.05);
                    }
                }
            }
            
            noteIndex = (noteIndex + 1) % melody.length;
        }, 150); // Tempo (150ms per note)
    }

    function stopMusic() {
        isMusicPlaying = false;
        if (musicInterval) clearInterval(musicInterval);
    }


    // --- GAME LOGIC ---
    let gameState = "START"; 
    let frameCount = 0;
    let level = 1;
    let burstCharges = 1;
    
    const floorY = 400;
    const waterY = 350;
    const leftLandEnd = 150;
    const rightLandStart = 650;

    const duck = {
        x: 50,
        y: 300,
        w: 32,
        h: 32,
        dy: 0,
        dx: 1.5, 
        gravity: 0.5,
        swimPower: -6,  
        burstPower: -14, 
        state: 'ground' 
    };

    let enemies = [];

    function initLevel() {
        duck.x = 50;
        duck.y = 300;
        duck.dy = 0;
        duck.state = 'ground';
        
        enemies = [];
        
        let sharkSpeed = 1.0 + (level * 0.2); 
        if (sharkSpeed > 5) sharkSpeed = 5; 

        enemies.push({
            type: 'shark',
            x: 300 + Math.random() * 100,
            y: waterY + 10, 
            w: 40,
            h: 20,
            dx: -sharkSpeed,
            dy: 0,
            dir: -1 
        });

        enemies.push({
            type: 'gator',
            x: 500 + Math.random() * 100,
            y: waterY, 
            w: 48,
            h: 24,
            dx: -0.5, 
            dy: 0,
            canJump: level > 1, 
            jumpTimer: 0
        });
    }

    function drawRect(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(Math.round(x), Math.round(y), w, h);
    }

    function drawPixelDuck(x, y) {
        drawRect(x + 4, y + 8, 20, 16, '#ffcc00'); 
        drawRect(x + 8, y, 16, 12, '#ffcc00'); 
        drawRect(x + 18, y + 2, 4, 4, 'black'); 
        drawRect(x + 20, y + 2, 2, 2, 'white');
        drawRect(x + 22, y + 6, 8, 4, '#ff6600'); 
        drawRect(x + 0, y + 12, 12, 8, '#e6b800'); 
    }

    function drawPixelShark(enemy) {
        let x = enemy.x;
        let y = enemy.y;
        drawRect(x + 16, y - 12, 8, 12, 'gray'); 
        drawRect(x, y, 40, 20, 'gray'); 
        drawRect(x + 4, y + 4, 4, 4, 'white'); 
        drawRect(x + 4, y + 4, 2, 2, 'black');
        drawRect(x + 2, y + 14, 12, 4, 'white'); 
    }

    function drawPixelGator(enemy) {
        let x = enemy.x;
        let y = enemy.y;
        drawRect(x, y, 48, 16, '#00aa00'); 
        drawRect(x - 12, y + 4, 12, 8, '#00aa00'); 
        drawRect(x + 4, y - 4, 6, 6, 'white'); 
        drawRect(x + 6, y - 4, 2, 4, 'black');
        drawRect(x + 10, y - 4, 4, 4, '#006600'); 
        drawRect(x + 20, y - 4, 4, 4, '#006600');
        drawRect(x + 30, y - 4, 4, 4, '#006600');
    }

    function drawEnvironment() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#d2691e';
        ctx.fillRect(0, floorY, leftLandEnd, canvas.height - floorY);
        ctx.fillStyle = '#00aa00';
        ctx.fillRect(0, floorY, leftLandEnd, 10);
        
        ctx.fillStyle = '#d2691e';
        ctx.fillRect(rightLandStart, floorY, canvas.width - rightLandStart, canvas.height - floorY);
        ctx.fillStyle = '#00aa00';
        ctx.fillRect(rightLandStart, floorY, canvas.width - rightLandStart, 10);

        ctx.fillStyle = 'rgba(0, 100, 255, 0.7)'; 
        ctx.fillRect(leftLandEnd, waterY + 15, rightLandStart - leftLandEnd, canvas.height - waterY);
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for(let i = leftLandEnd; i < rightLandStart; i+= 20) {
            let waveH = Math.sin((frameCount + i) * 0.05) * 3;
            ctx.moveTo(i, waterY + 15 + waveH);
            ctx.lineTo(i + 20, waterY + 15 - waveH);
        }
        ctx.stroke();
    }

    function updatePhysics() {
        let inWaterZone = duck.x > leftLandEnd - 10 && duck.x < rightLandStart;
        
        duck.dy += duck.gravity;
        duck.y += duck.dy;

        if (gameState === "PLAYING" && duck.x < rightLandStart + 50) {
            duck.x += duck.dx;
        }

        if (inWaterZone) {
            if (duck.y + duck.h > waterY + 20) {
                duck.y = waterY + 20 - duck.h;
                duck.dy = 0;
                duck.state = 'water';
                duck.y += Math.sin(frameCount * 0.1) * 2; 
            } else {
                duck.state = 'air';
            }
        } else {
            if (duck.y + duck.h > floorY) {
                duck.y = floorY - duck.h;
                duck.dy = 0;
                duck.state = 'ground';
            } else {
                duck.state = 'air';
            }
        }

        enemies.forEach(enemy => {
            if (enemy.type === 'shark') {
                enemy.x += enemy.dx;
                if (enemy.x < leftLandEnd || enemy.x > rightLandStart - 40) {
                    enemy.dx *= -1;
                }
                if (enemy.y < waterY + 5) enemy.y = waterY + 5;
            }
            
            if (enemy.type === 'gator') {
                enemy.x += enemy.dx;
                if (enemy.x < leftLandEnd + 50) enemy.x = rightLandStart - 50;
                enemy.dy += 0.4;
                enemy.y += enemy.dy;

                if (enemy.y > waterY) {
                    enemy.y = waterY;
                    enemy.dy = 0;
                    if (enemy.canJump) {
                        enemy.jumpTimer++;
                        if (enemy.jumpTimer > 150 && Math.random() > 0.95) {
                            enemy.dy = -12; 
                            enemy.jumpTimer = 0;
                        }
                    }
                }
            }

            if (gameState === "PLAYING") {
                if (
                    duck.x < enemy.x + enemy.w - 5 &&
                    duck.x + duck.w > enemy.x + 5 &&
                    duck.y < enemy.y + enemy.h - 5 &&
                    duck.y + duck.h > enemy.y + 5
                ) {
                    gameOver();
                }
            }
        });

        if (gameState === "PLAYING" && duck.x > rightLandStart + 20) {
            nextLevel();
        }
    }

    function nextLevel() {
        gameState = "WIN"; 
        level++;
        burstCharges++;
        sfxWin(); // Play Win Sound
        
        draw(); 
        
        setTimeout(() => {
            initLevel();
            gameState = "PLAYING";
            levelDisplay.innerText = level;
            burstDisplay.innerText = burstCharges;
            if (!isMusicPlaying) startBackgroundMusic(); // Restart music
        }, 2000);
    }

    function gameOver() {
        sfxDie(); // Play Die Sound
        gameState = "GAMEOVER";
    }

    function draw() {
        drawEnvironment();

        enemies.forEach(enemy => {
            if (enemy.type === 'shark') drawPixelShark(enemy);
            if (enemy.type === 'gator') drawPixelGator(enemy);
        });

        drawPixelDuck(duck.x, duck.y);

        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 0;

        if (gameState === "START") {
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.font = "40px Courier New";
            ctx.fillText("8-BIT DUCK SURVIVAL", canvas.width/2, 180);
            ctx.font = "20px Courier New";
            ctx.fillText("Press SPACE to Start", canvas.width/2, 230);
            ctx.font = "14px Courier New";
            ctx.fillStyle = "yellow";
            ctx.fillText("(Sound Enabled)", canvas.width/2, 260);
        } 
        else if (gameState === "GAMEOVER") {
            ctx.fillStyle = "rgba(150,0,0,0.7)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.font = "50px Courier New";
            ctx.fillText("YOU DIED", canvas.width/2, 200);
            ctx.font = "20px Courier New";
            ctx.fillText("Reload page to restart", canvas.width/2, 250);
        }
        else if (gameState === "WIN") {
            ctx.font = "40px Courier New";
            ctx.fillStyle = "yellow";
            ctx.fillText("LEVEL COMPLETE!", canvas.width/2, 200);
            ctx.fillStyle = "white";
            ctx.font = "20px Courier New";
            ctx.fillText("+1 Burst Charge Earned", canvas.width/2, 240);
        }
    }

    function handleJump() {
        // INIT AUDIO ON FIRST INTERACTION
        initAudio();

        if (gameState === "START") {
            gameState = "PLAYING";
            initLevel();
            return;
        }
        if (gameState !== "PLAYING") return;
        
        duck.dy = duck.swimPower;
        sfxJump(); // Play Jump Sound
    }

    function handleBurst() {
        initAudio();
        if (gameState !== "PLAYING") return;
        if (burstCharges > 0) {
            duck.dy = duck.burstPower;
            burstCharges--;
            burstDisplay.innerText = burstCharges;
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            sfxBurst(); // Play Burst Sound
        }
    }

    window.addEventListener('keydown', (e) => {
        if (e.code === 'Space') handleJump();
        if (e.key === 'Shift') handleBurst();
    });
    canvas.addEventListener('mousedown', handleJump);

    function loop() {
        if (gameState === "PLAYING" || gameState === "WIN") {
            updatePhysics();
            frameCount++;
        }
        draw();
        requestAnimationFrame(loop);
    }

    initLevel();
    loop();

</script>
</body>
</html>