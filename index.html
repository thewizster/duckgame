<!DOCTYPE html>
<html>
<head>
    <title>8-Bit Duck Survival</title>
    <style>
        body {
            margin: 0;
            background-color: #202020;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            user-select: none;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 40px rgba(0,0,0,0.8);
            border: 4px solid #fff;
        }
        canvas {
            background-color: #5c94fc;
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        .hp-bar {
            color: #ff6666;
        }
        .hp-progress {
            position: absolute;
            top: 95px;
            left: 10px;
            color: #88ddff;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }
        .hp-progress-bar {
            width: 100px;
            height: 8px;
            background-color: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.4);
            margin-top: 2px;
        }
        .hp-progress-fill {
            height: 100%;
            background-color: #88ddff;
            transition: width 0.1s linear;
        }
        .controls {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 0 #000;
            opacity: 0.8;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <div id="ui">
            LEVEL: <span id="levelDisplay">1</span><br>
            BURSTS: <span id="burstDisplay">1</span> ⚡<br>
            <span class="hp-bar">HP: <span id="hpDisplay">100</span> ❤</span>
        </div>
        <div id="hpProgressContainer" class="hp-progress">
            <div style="margin-bottom: 2px;">HP Regen: <span id="hpProgressText">0.0s</span></div>
            <div class="hp-progress-bar">
                <div id="hpProgressFill" class="hp-progress-fill" style="width: 0%;"></div>
            </div>
        </div>
        <canvas id="gameCanvas" width="800" height="450"></canvas>
        <div class="controls">SPACE: Swim/Hop | SHIFT: Super Burst Flight</div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const levelDisplay = document.getElementById('levelDisplay');
    const burstDisplay = document.getElementById('burstDisplay');
    const hpDisplay = document.getElementById('hpDisplay');
    const hpProgressText = document.getElementById('hpProgressText');
    const hpProgressFill = document.getElementById('hpProgressFill');
    const hpProgressContainer = document.getElementById('hpProgressContainer');

    // --- AUDIO ENGINE (Retro Synths) ---
    let audioCtx = null;
    let musicInterval = null;
    let isMusicPlaying = false;

    // FIXED: Added missing high notes (D5, etc) to prevent crashes
    const noteFreqs = {
        C3: 130.81, D3: 146.83, E3: 164.81, F3: 174.61, G3: 196.00, A3: 220.00, B3: 246.94,
        C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.00, A4: 440.00, B4: 493.88,
        C5: 523.25, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99
    };

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        if (!isMusicPlaying) {
            startBackgroundMusic();
        }
    }

    function playTone(freq, type, duration, volume = 0.1) {
        if (!audioCtx) return;
        if (!freq) return; // Safety check: don't crash if note is missing

        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        osc.type = type; 
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        
        // Smooth envelope to avoid clicking sounds
        gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function sfxJump() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, audioCtx.currentTime);
        osc.frequency.linearRampToValueAtTime(300, audioCtx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);
    }

    function sfxBurst() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.3);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.3);
    }

    function sfxDie() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
        gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.5);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.5);
        stopMusic();
    }

    function sfxWin() {
        if (!audioCtx) return;
        let now = audioCtx.currentTime;
        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, now + i*0.1);
            gain.gain.linearRampToValueAtTime(0, now + i*0.1 + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now + i*0.1);
            osc.stop(now + i*0.1 + 0.1);
        });
    }

    function startBackgroundMusic() {
        if (isMusicPlaying) return;
        isMusicPlaying = true;
        
        let noteIndex = 0;
        const melody = [
            'C4', 'E4', 'G4', 'C5', 'G4', 'E4', 'C4', 'P',
            'D4', 'F4', 'A4', 'D5', 'A4', 'F4', 'D4', 'P',
            'E4', 'G4', 'B4', 'E5', 'B4', 'G4', 'E4', 'P',
            'G3', 'B3', 'D4', 'G4', 'D4', 'B3', 'G3', 'P' 
        ];

        musicInterval = setInterval(() => {
            // Only play music if game is actually in PLAYING state
            if (gameState !== "PLAYING") return;
            
            let note = melody[noteIndex];
            if (note !== 'P') { 
                // Main Melody
                playTone(noteFreqs[note], 'square', 0.1, 0.03); 
                
                // Bassline (Simple 1-5 pattern)
                if (noteIndex % 4 === 0) {
                    // If freq exists, play bass an octave lower
                    if (noteFreqs[note]) {
                        playTone(noteFreqs[note] / 2, 'triangle', 0.2, 0.05);
                    }
                }
            }
            
            noteIndex = (noteIndex + 1) % melody.length;
        }, 150); // Tempo (150ms per note)
    }

    function stopMusic() {
        isMusicPlaying = false;
        if (musicInterval) clearInterval(musicInterval);
    }


    // --- GAME LOGIC ---
    let gameState = "START"; 
    let frameCount = 0;
    let level = 1;
    let burstCharges = 1;
    let hp = 100;
    let maxHp = 100;
    let waterTime = 0; // Time spent on water
    const HP_GAIN_INTERVAL = 60; // Frames (1 second at 60fps)
    const COLLISION_KNOCKBACK = 50; // Pixels to push back on collision
    const COLLISION_DAMAGE = 25; // HP lost per collision
    
    // --- HIGH SCORE SYSTEM ---
    let highScores = [];
    let isNewHighScore = false;
    let playerInitials = ['A', 'A', 'A'];
    let currentInitialIndex = 0;
    const ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    function loadHighScores() {
        const saved = localStorage.getItem('duckGameHighScores');
        if (saved) {
            highScores = JSON.parse(saved);
        }
    }
    
    function saveHighScores() {
        localStorage.setItem('duckGameHighScores', JSON.stringify(highScores));
    }
    
    function isTopScore(level) {
        if (highScores.length < 5) return true;
        return level > highScores[highScores.length - 1].level;
    }
    
    function addHighScore(initials, level) {
        highScores.push({ initials: initials.join(''), level: level });
        highScores.sort((a, b) => b.level - a.level);
        highScores = highScores.slice(0, 5);
        saveHighScores();
    }
    
    const floorY = 400;
    const waterY = 350;
    const leftLandEnd = 150;
    const rightLandStart = 650;

    const duck = {
        x: 50,
        y: 300,
        w: 32,
        h: 32,
        dy: 0,
        dx: 1.5, 
        gravity: 0.5,
        swimPower: -6,  
        burstPower: -14, 
        state: 'ground' 
    };

    let enemies = [];

    function initLevel() {
        duck.x = 50;
        duck.y = 300;
        duck.dy = 0;
        duck.state = 'ground';
        
        // Don't reset HP - it should persist across levels
        // Only update the display
        hpDisplay.innerText = hp;
        waterTime = 0;
        
        // Show HP progress indicator for the level
        hpProgressContainer.style.display = 'block';
        hpProgressFill.style.width = '0%';
        hpProgressText.innerText = '1.0s';
        
        enemies = [];
        
        let sharkSpeed = 1.0 + (level * 0.2); 
        if (sharkSpeed > 5) sharkSpeed = 5; 

        enemies.push({
            type: 'shark',
            x: 300 + Math.random() * 100,
            y: waterY + 10, 
            w: 40,
            h: 20,
            dx: -sharkSpeed,
            dy: 0,
            dir: -1 
        });

        enemies.push({
            type: 'gator',
            x: 500 + Math.random() * 100,
            y: waterY, 
            w: 48,
            h: 24,
            dx: -0.5, 
            dy: 0,
            canJump: level > 1, 
            jumpTimer: 0
        });
    }

    function drawRect(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(Math.round(x), Math.round(y), w, h);
    }

    function drawPixelDuck(x, y) {
        drawRect(x + 4, y + 8, 20, 16, '#ffcc00'); 
        drawRect(x + 8, y, 16, 12, '#ffcc00'); 
        drawRect(x + 18, y + 2, 4, 4, 'black'); 
        drawRect(x + 20, y + 2, 2, 2, 'white');
        drawRect(x + 22, y + 6, 8, 4, '#ff6600'); 
        drawRect(x + 0, y + 12, 12, 8, '#e6b800'); 
    }

    function drawPixelShark(enemy) {
        let x = enemy.x;
        let y = enemy.y;
        drawRect(x + 16, y - 12, 8, 12, 'gray'); 
        drawRect(x, y, 40, 20, 'gray'); 
        drawRect(x + 4, y + 4, 4, 4, 'white'); 
        drawRect(x + 4, y + 4, 2, 2, 'black');
        drawRect(x + 2, y + 14, 12, 4, 'white'); 
    }

    function drawPixelGator(enemy) {
        let x = enemy.x;
        let y = enemy.y;
        drawRect(x, y, 48, 16, '#00aa00'); 
        drawRect(x - 12, y + 4, 12, 8, '#00aa00'); 
        drawRect(x + 4, y - 4, 6, 6, 'white'); 
        drawRect(x + 6, y - 4, 2, 4, 'black');
        drawRect(x + 10, y - 4, 4, 4, '#006600'); 
        drawRect(x + 20, y - 4, 4, 4, '#006600');
        drawRect(x + 30, y - 4, 4, 4, '#006600');
    }

    function drawEnvironment() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#d2691e';
        ctx.fillRect(0, floorY, leftLandEnd, canvas.height - floorY);
        ctx.fillStyle = '#00aa00';
        ctx.fillRect(0, floorY, leftLandEnd, 10);
        
        ctx.fillStyle = '#d2691e';
        ctx.fillRect(rightLandStart, floorY, canvas.width - rightLandStart, canvas.height - floorY);
        ctx.fillStyle = '#00aa00';
        ctx.fillRect(rightLandStart, floorY, canvas.width - rightLandStart, 10);

        ctx.fillStyle = 'rgba(0, 100, 255, 0.7)'; 
        ctx.fillRect(leftLandEnd, waterY + 15, rightLandStart - leftLandEnd, canvas.height - waterY);
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        for(let i = leftLandEnd; i < rightLandStart; i+= 20) {
            let waveH = Math.sin((frameCount + i) * 0.05) * 3;
            ctx.moveTo(i, waterY + 15 + waveH);
            ctx.lineTo(i + 20, waterY + 15 - waveH);
        }
        ctx.stroke();
    }

    function updatePhysics() {
        let inWaterZone = duck.x > leftLandEnd - 10 && duck.x < rightLandStart;
        
        duck.dy += duck.gravity;
        duck.y += duck.dy;

        if (gameState === "PLAYING" && duck.x < rightLandStart + 50) {
            duck.x += duck.dx;
        }

        if (inWaterZone) {
            if (duck.y + duck.h > waterY + 20) {
                duck.y = waterY + 20 - duck.h;
                duck.dy = 0;
                duck.state = 'water';
                duck.y += Math.sin(frameCount * 0.1) * 2; 
                
                // REWARD SYSTEM: Gain HP for staying on water
                if (gameState === "PLAYING") {
                    waterTime++;
                    
                    // Update progress indicator
                    const progress = (waterTime / HP_GAIN_INTERVAL) * 100;
                    const secondsRemaining = ((HP_GAIN_INTERVAL - waterTime) / 60).toFixed(1);
                    hpProgressFill.style.width = progress + '%';
                    hpProgressText.innerText = secondsRemaining + 's';
                    
                    // Every second (60 frames) on water, gain 10 HP
                    if (waterTime >= HP_GAIN_INTERVAL) {
                        if (hp < maxHp) {
                            hp = Math.min(hp + 10, maxHp);
                            hpDisplay.innerText = hp;
                            // Visual feedback - play a subtle tone
                            playTone(noteFreqs.E5, 'sine', 0.05, 0.02);
                        }
                        waterTime = 0; // Reset to restart the indicator
                    }
                }
            } else {
                duck.state = 'air';
                // Don't reset waterTime - just pause it (keep visual visible)
            }
        } else {
            if (duck.y + duck.h > floorY) {
                duck.y = floorY - duck.h;
                duck.dy = 0;
                duck.state = 'ground';
                // Don't reset waterTime - just pause it (keep visual visible)
            } else {
                duck.state = 'air';
                // Don't reset waterTime - just pause it (keep visual visible)
            }
        }

        enemies.forEach(enemy => {
            if (enemy.type === 'shark') {
                enemy.x += enemy.dx;
                if (enemy.x < leftLandEnd || enemy.x > rightLandStart - 40) {
                    enemy.dx *= -1;
                }
                if (enemy.y < waterY + 5) enemy.y = waterY + 5;
            }
            
            if (enemy.type === 'gator') {
                enemy.x += enemy.dx;
                if (enemy.x < leftLandEnd + 50) enemy.x = rightLandStart - 50;
                enemy.dy += 0.4;
                enemy.y += enemy.dy;

                if (enemy.y > waterY) {
                    enemy.y = waterY;
                    enemy.dy = 0;
                    if (enemy.canJump) {
                        enemy.jumpTimer++;
                        if (enemy.jumpTimer > 150 && Math.random() > 0.95) {
                            enemy.dy = -12; 
                            enemy.jumpTimer = 0;
                        }
                    }
                }
            }

            if (gameState === "PLAYING") {
                if (
                    duck.x < enemy.x + enemy.w - 5 &&
                    duck.x + duck.w > enemy.x + 5 &&
                    duck.y < enemy.y + enemy.h - 5 &&
                    duck.y + duck.h > enemy.y + 5
                ) {
                    // Reduce HP by collision damage
                    hp -= COLLISION_DAMAGE;
                    hpDisplay.innerText = hp;
                    
                    // Push duck back to avoid repeated collisions
                    duck.x -= COLLISION_KNOCKBACK;
                    if (duck.x < 0) duck.x = 0;
                    
                    // Play hit sound
                    playTone(noteFreqs.C3, 'sawtooth', 0.2, 0.1);
                    
                    // Check if HP reached zero
                    if (hp <= 0) {
                        gameOver();
                    }
                }
            }
        });

        if (gameState === "PLAYING" && duck.x > rightLandStart + 20) {
            nextLevel();
        }
    }

    function nextLevel() {
        gameState = "WIN"; 
        level++;
        burstCharges++;
        sfxWin(); // Play Win Sound
        
        draw(); 
        
        setTimeout(() => {
            initLevel();
            gameState = "PLAYING";
            levelDisplay.innerText = level;
            burstDisplay.innerText = burstCharges;
            if (!isMusicPlaying) startBackgroundMusic(); // Restart music
        }, 2000);
    }

    function gameOver() {
        sfxDie(); // Play Die Sound
        
        // Check if player made top 5
        if (isTopScore(level)) {
            isNewHighScore = true;
            playerInitials = ['A', 'A', 'A'];
            currentInitialIndex = 0;
            gameState = "ENTER_INITIALS";
        } else {
            gameState = "GAMEOVER";
        }
    }

    function drawInitialEntry() {
        ctx.fillStyle = "rgba(0,0,0,0.85)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Title
        ctx.fillStyle = "yellow";
        ctx.font = "40px Courier New";
        ctx.textAlign = "center";
        ctx.fillText("NEW HIGH SCORE!", canvas.width/2, 100);
        
        ctx.fillStyle = "white";
        ctx.font = "24px Courier New";
        ctx.fillText(`Level ${level} Completed`, canvas.width/2, 140);
        
        // Instructions
        ctx.font = "16px Courier New";
        ctx.fillStyle = "#aaa";
        ctx.fillText("Enter Your Initials:", canvas.width/2, 190);
        
        // Draw initial boxes
        const boxWidth = 60;
        const boxHeight = 80;
        const spacing = 20;
        const startX = canvas.width/2 - (boxWidth * 1.5 + spacing);
        const boxY = 220;
        
        for (let i = 0; i < 3; i++) {
            const x = startX + i * (boxWidth + spacing);
            
            // Box
            if (i === currentInitialIndex) {
                ctx.strokeStyle = "yellow";
                ctx.lineWidth = 4;
            } else {
                ctx.strokeStyle = "#555";
                ctx.lineWidth = 2;
            }
            ctx.strokeRect(x, boxY, boxWidth, boxHeight);
            
            // Letter
            ctx.fillStyle = i === currentInitialIndex ? "yellow" : "white";
            ctx.font = "48px Courier New";
            ctx.fillText(playerInitials[i], x + boxWidth/2, boxY + 60);
        }
        
        // Arrow indicators for current letter
        if (frameCount % 60 < 30) {
            const x = startX + currentInitialIndex * (boxWidth + spacing);
            ctx.fillStyle = "yellow";
            ctx.font = "30px Courier New";
            ctx.fillText("▲", x + boxWidth/2, boxY - 10);
            ctx.fillText("▼", x + boxWidth/2, boxY + boxHeight + 35);
        }
        
        // Controls
        ctx.font = "14px Courier New";
        ctx.fillStyle = "#aaa";
        ctx.fillText("↑↓: Change Letter  |  ←→: Move Position  |  ENTER: Confirm", canvas.width/2, 370);
    }
    
    function drawScoreboard() {
        const boardWidth = 400;
        const boardHeight = 280;
        const boardX = canvas.width/2 - boardWidth/2;
        const boardY = 80;
        
        // Board background
        ctx.fillStyle = "rgba(0,0,0,0.9)";
        ctx.fillRect(boardX, boardY, boardWidth, boardHeight);
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 3;
        ctx.strokeRect(boardX, boardY, boardWidth, boardHeight);
        
        // Title
        ctx.fillStyle = "yellow";
        ctx.font = "28px Courier New";
        ctx.textAlign = "center";
        ctx.fillText("★ HIGH SCORES ★", canvas.width/2, boardY + 35);
        
        // Headers
        ctx.fillStyle = "#aaa";
        ctx.font = "16px Courier New";
        ctx.textAlign = "left";
        ctx.fillText("RANK", boardX + 30, boardY + 70);
        ctx.fillText("PLAYER", boardX + 120, boardY + 70);
        ctx.textAlign = "right";
        ctx.fillText("LEVEL", boardX + boardWidth - 30, boardY + 70);
        
        // Divider
        ctx.strokeStyle = "#555";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(boardX + 20, boardY + 80);
        ctx.lineTo(boardX + boardWidth - 20, boardY + 80);
        ctx.stroke();
        
        // Scores
        ctx.font = "20px Courier New";
        for (let i = 0; i < 5; i++) {
            const y = boardY + 115 + i * 30;
            
            if (i < highScores.length) {
                ctx.fillStyle = i === 0 ? "gold" : i === 1 ? "silver" : i === 2 ? "#cd7f32" : "white";
                ctx.textAlign = "left";
                ctx.fillText(`${i + 1}.`, boardX + 30, y);
                ctx.fillText(highScores[i].initials, boardX + 120, y);
                ctx.textAlign = "right";
                ctx.fillText(highScores[i].level.toString(), boardX + boardWidth - 30, y);
            } else {
                ctx.fillStyle = "#333";
                ctx.textAlign = "left";
                ctx.fillText(`${i + 1}.`, boardX + 30, y);
                ctx.fillText("---", boardX + 120, y);
                ctx.textAlign = "right";
                ctx.fillText("-", boardX + boardWidth - 30, y);
            }
        }
    }

    function draw() {
        drawEnvironment();

        enemies.forEach(enemy => {
            if (enemy.type === 'shark') drawPixelShark(enemy);
            if (enemy.type === 'gator') drawPixelGator(enemy);
        });

        drawPixelDuck(duck.x, duck.y);

        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 0;

        if (gameState === "START") {
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.font = "40px Courier New";
            ctx.fillText("8-BIT DUCK SURVIVAL", canvas.width/2, 180);
            ctx.font = "20px Courier New";
            ctx.fillText("Press SPACE to Start", canvas.width/2, 230);
            ctx.font = "14px Courier New";
            ctx.fillStyle = "yellow";
            ctx.fillText("(Sound Enabled)", canvas.width/2, 260);
        } 
        else if (gameState === "ENTER_INITIALS") {
            drawInitialEntry();
        }
        else if (gameState === "GAMEOVER") {
            ctx.fillStyle = "rgba(150,0,0,0.7)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = "white";
            ctx.font = "50px Courier New";
            ctx.fillText("YOU DIED", canvas.width/2, 140);
            ctx.font = "24px Courier New";
            ctx.fillText(`Level ${level} Reached`, canvas.width/2, 180);
            
            // Draw scoreboard
            drawScoreboard();
            
            ctx.font = "16px Courier New";
            ctx.fillStyle = "#aaa";
            ctx.fillText("Reload page to restart", canvas.width/2, 400);
        }
        else if (gameState === "WIN") {
            ctx.font = "40px Courier New";
            ctx.fillStyle = "yellow";
            ctx.fillText("LEVEL COMPLETE!", canvas.width/2, 200);
            ctx.fillStyle = "white";
            ctx.font = "20px Courier New";
            ctx.fillText("+1 Burst Charge Earned", canvas.width/2, 240);
        }
    }

    function handleJump() {
        // INIT AUDIO ON FIRST INTERACTION
        initAudio();

        if (gameState === "START") {
            gameState = "PLAYING";
            initLevel();
            return;
        }
        if (gameState !== "PLAYING") return;
        
        duck.dy = duck.swimPower;
        sfxJump(); // Play Jump Sound
    }

    function handleBurst() {
        initAudio();
        if (gameState !== "PLAYING") return;
        if (burstCharges > 0) {
            duck.dy = duck.burstPower;
            burstCharges--;
            burstDisplay.innerText = burstCharges;
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            sfxBurst(); // Play Burst Sound
        }
    }

    window.addEventListener('keydown', (e) => {
        // Initial entry controls
        if (gameState === "ENTER_INITIALS") {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                const currentChar = playerInitials[currentInitialIndex];
                const charIndex = ALPHABET.indexOf(currentChar);
                playerInitials[currentInitialIndex] = ALPHABET[(charIndex + 1) % ALPHABET.length];
                playTone(noteFreqs.C5, 'square', 0.05, 0.05);
            }
            else if (e.key === 'ArrowDown') {
                e.preventDefault();
                const currentChar = playerInitials[currentInitialIndex];
                const charIndex = ALPHABET.indexOf(currentChar);
                playerInitials[currentInitialIndex] = ALPHABET[(charIndex - 1 + ALPHABET.length) % ALPHABET.length];
                playTone(noteFreqs.C5, 'square', 0.05, 0.05);
            }
            else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                currentInitialIndex = Math.max(0, currentInitialIndex - 1);
                playTone(noteFreqs.E5, 'square', 0.05, 0.05);
            }
            else if (e.key === 'ArrowRight') {
                e.preventDefault();
                currentInitialIndex = Math.min(2, currentInitialIndex + 1);
                playTone(noteFreqs.E5, 'square', 0.05, 0.05);
            }
            else if (e.key === 'Enter') {
                e.preventDefault();
                addHighScore(playerInitials, level);
                sfxWin();
                gameState = "GAMEOVER";
            }
            return;
        }
        
        // Normal game controls
        if (e.code === 'Space') handleJump();
        if (e.key === 'Shift') handleBurst();
    });
    canvas.addEventListener('mousedown', handleJump);

    function loop() {
        if (gameState === "PLAYING" || gameState === "WIN") {
            updatePhysics();
            frameCount++;
        }
        draw();
        requestAnimationFrame(loop);
    }

    loadHighScores();
    initLevel();
    loop();

</script>
</body>
</html>